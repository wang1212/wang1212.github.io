<p>　　最近在做 Node.js 技术相关的调研，需要选定一个 Web 框架作为基础来构建业务。一般来说，首选开源方案，对于我来说，比较关注框架背后的开发团队情况、项目活跃度、是否有足够多的商业案例、文档是否完整可读、框架的设计理念、技术架构是否灵活可扩展、技术社区生态是否完整等方面。目前，我比较倾心的是 Fastify 这个新兴框架，根据官网介绍，其专注于高性能和低消耗，并且公开的基准测试表现相当不错，项目足够活跃，更重要的是属于 OpenJS 基金会的孵化项目。本文主要介绍 Fastify 的设计理念和探究其是如何提高性能和降低内存消耗的。</p>
<blockquote>
<p>Fastify 官网：<a href="https://www.fastify.io/">https://www.fastify.io/</a></p>
</blockquote>
<p>　　Fastify v1.0.0 发布是在 2018 年的 3 月份，相比于业内广为熟知的 Express / Koa 等框架还很年轻，其项目发起者和核心维护者之一 Matteo Collina 也在开源社区很有声望，是 Node.js TSC 成员，目前 Fastify 项目已经加入 OpenJS 基金会。</p>
<blockquote>
<p><a href="https://medium.com/the-node-js-collection/fastify-goes-lts-with-1-0-0-911112c64752">Fastify 到达 1.0.0  LTS！</a></p>
<p><a href="https://openjsf.org/blog/2019/11/20/web-framework-fastify-joins-openjs-foundation-as-an-incubating-project/">Fastify 作为孵化项目加入 OpenJS 基金会</a></p>
<p><a href="https://openjsf.org/blog/2020/08/27/fastify-graduation-performance-and-the-future/">Fastify：毕业、性能和未来</a></p>
</blockquote>
<h2 id="设计理念">设计理念</h2>
<p>　　一般来说，一个开源项目会在文档中阐述自己的设计理念和技术架构等理论层面的思考，以帮助开发者更快的了解项目的核心思想和目标人群，或者说解决的关键性问题。官网首页首先给出了标题为 Why 的一段话，然后列举了核心功能点（Core features），文档中没有找到具体阐述设计理念之类的东西。不过，在看了官方博客文章以及相关的资料之后，Fastify 的设计理念大体可以总结：</p>
<ul>
<li>高性能</li>
<li>灵活可扩展</li>
<li>开发人员友好（例如内置日志系统、TS 支持等等）</li>
</ul>
<p>　　纵观众多 Node.js Web 开源框架，大多都做到了后两点，例如 Express 项目利用中间件提供了足够的灵活性，内置了开箱即用的功能；而 Koa 为了改进开发人员的体验，引入 <code>async/await</code> 替代回调函数，以及所谓的 “洋葱模型” 提供了更高的灵活性，精简了框架核心，只提供必要的功能，从而有了比 Express 更好的性能。而 Fastify 除此之外，对性能有极致的追求，同时也提出了很多不一样的思想，值得学习。</p>
<p>　　其实，Web 开发框架还有一个较为严峻的问题就是项目的工程化标准，最著名的就是 MVC 模型，而对应的也有解决此类问题的 Node.js 框架，近年来发展前景比较好的应该就是 nest.js 了。</p>
<h2 id="fastify-的实现细节">Fastify 的实现细节</h2>
<p>　　了解了 Fastify 的设计理念之后，接下来要看看开发团队是如何实施的，探索其技术细节。</p>
<h3 id="fast-json-stringify"><code>fast-json-stringify</code></h3>
<p>　　Fastify 项目的历史故事背后是 <code>fast-json-stringify</code> 模块的诞生，该模块比 <code>JSON.stringify()</code> 这种原生 JavaScript 方法快很多，可以达到 2 到 3 倍的性能优势。其背后的原理主要是 <strong>依赖 JSON Schema 对 JSON 数据进行校验，避免了类型判断的过程，从而提高了性能</strong>。根据其公开的基准测试，其优势主要体现在处理的目标数据为复杂对象时，可以达到 4 倍的性能优势。</p>
<blockquote>
<p><a href="https://github.com/fastify/fast-json-stringify">GitHub: <code>fast-json-stringify</code></a></p>
<p><a href="https://json-schema.org/">JSON Schema</a></p>
</blockquote>
<p>　　其中有两个细节我们值得注意。第一个便是项目 <em>README.md</em> 文件中提到的安全方面需要注意的问题，是由于 <strong>在初始化时利用 <code>Function</code> 构造函数预编译了函数体，以此达到优化性能的目的</strong>。</p>
<pre><code class="language-js">result = (<span class="hljs-name">new</span> Function('schema', code))(<span class="hljs-name">root</span>)</code></pre>
<p>　　而这个原理其实也是比较好理解的，通过把一个函数体内包含循环迭代的代码预先“编译”成字符串再交给函数来执行，在函数的“运行时”就不需要再做额外的“解释翻译”以及迭代工作，从而提高性能。下面有一篇相关的比较有趣的文章可以看看：</p>
<blockquote>
<p><a href="https://github.com/felixge/faster-than-c">Faster than C? Parsing binary data in JavaScript.</a></p>
</blockquote>
<p>　　第二个细节便是 <em>README.md</em> 文件中有提到可以和 <code>flatstr</code> 模块很好的配合使用，因为该模块会触发 V8 的优化机制，把字符串最终转换成了 <code>Buffer</code>。 其项目的 <em>README.md</em> 文件中 <strong>How does it work</strong> 段落详细解释了底层机制，简单的来说，v8 会在某些情况下针对 <code>String</code> 数据做特定优化，而该模块的主要作用就是主动去触发这种 v8 的优化机制以达到提高性能的目的。</p>
<blockquote>
<p><a href="https://github.com/davidmarkclements/flatstr">GitHub: <code>flatstr</code></a></p>
</blockquote>
