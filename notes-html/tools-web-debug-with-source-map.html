<p>　　Web 项目出于加载性能优化和安全考虑，在生产环境部署的构建好的代码是经过混淆和压缩的，这对根据线上收集的错误日志中的栈信息进行本地调试提出了挑战。</p>
<p>　　几个月前，新上线的项目接入 SkyWalking 日志后，出了一些兼容性问题，大部分问题根据客户反馈的交互流程基本可以猜到出问题的代码位置，尤其是可以使用测试机进行复现，在本地调试直接可以获知具体的错误栈信息。但其中有几个问题，由于客户的机型太小众，而且系统版本太旧，没有类似的测试机环境可以复现，只能根据线上收集到的错误日志和其中的栈信息定位错误。这看似是个很简单的问题，但实际上不好解决，因为线上日志的错误栈信息中对应的行列号是压缩和混淆后的代码，基本定位不到具体的源码位置。于是，一直在本地模拟用户的交互和测试数据，苦于无法复现，最终回过头来还是决定思考一下怎么根据栈信息定位错误。</p>
<p>　　当然，一个很明显的场景就是，本地使用 Webpack 这类构建工具进行开发时，代码本身在本地调试的过程中就已经进行了编译转换和合并，为了能在 Web 开发工具中定位到错误发生的源码位置，会生成 <strong>sourcemap</strong> 文件来解决这一问题。想到这里，调试线上问题的思路也基本明确了，那就是利用构建发布代码时生成的 <strong>sourcemap</strong> 文件配合获取的线上日志栈信息中行列号解析出源码的对应位置（文件，行列号）。此时，又出现了两个问题，第一个问题是原来的构建发布代码过程中出于安全考虑是不产生 <strong>sourcemap</strong> 文件的，当然回过头来想一下，只要目前的项目源码和当前线上发布时的是一致的，重新生成 sourcemap 文件也能解决问题；第二个问题就比较难办了，以前只是配置 Webpack，至于自己如何手动解析 sourcemap 倒还没尝试过，先是查了下资料，发现这个文件格式标准是 Google 提出来的，但没有找到官方提供的解析工具，不过后续却找到了一个 <em>Mozilla</em> 的开源项目 <a href="https://github.com/mozilla/source-map"><code>source-map</code></a> 解决了该问题。</p>
<h2 id="工具脚本">工具脚本</h2>
<p>　　有了 <strong>sourcemap</strong> 文件和解析工具其实就很好解决问题了，这里贴一下自己使用的工具脚本源码：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 调试压缩代码（要保留 dist 文件夹）
 * ! 上线前请注意不要把 sourcemap 文件一同发布
 */</span>
<span class="hljs-keyword">import</span> process <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;process&#x27;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
<span class="hljs-keyword">import</span> sourceMap <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;source-map&#x27;</span>;

<span class="hljs-comment">// * 第一步：更改要调试的压缩代码文件对应 sourcemap 文件名称</span>
<span class="hljs-keyword">let</span> sourcemap = fs.<span class="hljs-title function_">readFileSync</span>(path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;./dist/js/index.314d075b.js.map&#x27;</span>));
sourcemap = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(sourcemap);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> s = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> sourceMap.<span class="hljs-title class_">SourceMapConsumer</span>(sourcemap);

  <span class="hljs-comment">// * 第二步：将 `line` 和 `column` 更改为线上错误日志堆栈信息中的行列号</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">debug</span>(
    s.<span class="hljs-title function_">originalPositionFor</span>({
      <span class="hljs-attr">line</span>: <span class="hljs-number">15</span>,
      <span class="hljs-attr">column</span>: <span class="hljs-number">69</span>,
    })
  );

  s.<span class="hljs-title function_">destroy</span>();
}

<span class="hljs-comment">// * 最后运行脚本：`node scripts/debug-min-code.mjs`</span>
<span class="hljs-comment">// 查看打印出的实际文件和位置信息</span>
<span class="hljs-title function_">parse</span>();
</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://sourcemaps.info/spec.html">Source Map Revision 3 Proposal</a></li>
<li><a href="https://github.com/mozilla/source-map">source-map</a></li>
</ul>
