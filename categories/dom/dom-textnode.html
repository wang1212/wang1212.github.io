<!DOCTYPE html>
<html lang="zh-CN">
<body>
	<header class="jumbotron jumbotron-fluid">
		<div class="container">
			<h1 class="page-title display-4">DOM-文本节点</h1>
			<p>
				<span class="tag tag-danger">Web</span>&nbsp;&nbsp;&nbsp;
				<span class="tag tag-warning">DOM</span>&nbsp;&nbsp;&nbsp;
				<span class="tag tag-info">TextNode</span>
			</p>
			<p class="head-indent lead">
				文本（Text）节点虽然很多时候我们直接用 innerHTML 去赋值替换，但当我们进行一些细微的修改时，了解一下 DOM 操作还是非常有用的。
			</p>
			<hr />
			<p>
				<span id="time" class="tag tag-pill tag-success">发表于 2016-5-24</span>&nbsp;
				<span id="categories" class="tag tag-pill tag-success">分类 Dom</span>
			</p>
		</div>
	</header>
	<div class="container">
		<div class="row">
			<div class="col-md-9">
				<section>
					<h2>文本节点</h2>
					<p class="head-indent">文本节点的 DOM 操作是不常用的，我们通常直接用元素节点的<code>innerHTML</code>属性直接替换其所有文本节点，但当我们要对文本节点进行局部操作时 DOM 操作却是很有用的。下面列举一些文本节点常用的属性及方法：</p>
					<ul>
						<li>textContent</li>
						<li>appendData()</li>
						<li>deleteData()</li>
						<li>insertData()</li>
						<li>replaceData()</li>
						<li>subStringData()</li>
						<li>splitText()</li>
						<li>normalize</li>
						<li>Data</li>
					</ul>
					<p class="head-indent">需要注意的是，我们在元素节点中留下的空格、回车符、制表符等空白字符也是被解析成文本节点的，所以说我们不压缩页面代码的话，会有许多无用的文本节点影响性能。</p>
				</section>
				<section>
					<h2>文本节点的 DOM 操作</h2>
					<p class="head-indent">下面就详细介绍一下文本节点常用的 DOM 操作的过程，首先来了解一下如何创建一个文本节点并将其插入到 DOM 树中。</p>
					<section>
						<h3>创建节点并更新到 DOM 树</h3>
						<p class="head-indent">文本（Text）节点不同于元素节点，在<code>document</code>对象上也有专门用来创建文本节点的方法。 </p>
						<ul>
							<li>createTextNode()</li>
						</ul>
						<pre class="language-markup"><code>&lt;body&gt;
　　&lt;h1&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;script&gt;
　　var textO = document.createTextNode('Hello World!');
    document.querySelector('h1').appendChild(textO);
&lt;/script&gt;</code></pre>
					</section>
					<section>
						<h3>获取节点的文本值</h3>
						<p class="head-indent">文本节点的文本值是呈现出来给用户看的，但有些时候我们也需要让程序去获知被用户修改后的文本值。</p>
						<ul>
							<li>data</li>
							<li>nodeValue</li>
							<li>substringData()</li>
						</ul>
						<pre class="language-markup"><code>&lt;body&gt;
  	&lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/body&gt;
&lt;script&gt;
	var textO = document.querySelector('h1').firstChild;
	// 获取文本值
	console.log(texto.data); // Hello World!
	console.log(textO.nodeValue); // Hello World!
	// 获取文本值的长度
	console.log(textO.length);
	console.log(textO.data.length);
	console.log(textO.nodeValue.length);
	// 获取部分文本值（开始索引&lt;不包括&gt;，长度）
	console.log(textO.substringData(6,5)); // World
&lt;/script&gt;</code></pre>
					</section>
					<section>
						<h3>节点的文本值操作</h3>
						<p class="head-indent">文本节点的文本值事实上也是重要的数据，这涉及到一些查看、增添、删除、修改等操作。</p>
						<ul>
							<li>appendData()</li>
							<li>deleteData()</li>
							<li>insertData()</li>
							<li>replaceData()</li>
							<li>splitText()</li>
						</ul>
						<pre class="language-markup"><code>&lt;body&gt;
  	&lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/body&gt;
&lt;script&gt;
	var textO = document.querySelector('h1').firstChild;
	// 添加（尾部附加）
	textO.appendData('!');
	console.log(textO.data); // Hello World!
	// 删除（删除位置索引&lt;不包括&gt;，删除长度）
	textO.deleteData(7,4);
	console.log(textO.data); // Hello W!
	// 插入（插入位置索引&lt;其后插入&gt;，插入值）
	textO.insertData(7,'orld');
	console.log(textO.data); // Hello World!
	// 替换（替换位置索引&lt;不包括&gt;，替换长度，替换值）
	textO.replaceData(6,5,'China')
	console.log(textO.data); // Hello China!
	// 分割（分割位置索引&lt;不包括&gt;，分割长度）
	var sText = textO.splitText(6,5);
	console.log(sText.data); // China!
&lt;/script&gt;</code></pre>
						<p class="head-indent"><code>splitText()</code>方法会按要求将一个文本节点分割成多个文本节点，同时还会返回包含分割部分的文本节点对象。</p>
					</section>
					<section>
						<h3>多个文本节点的情况</h3>
						<p class="head-indent">当我们在一个元素节点内写了很多文本值时，只要它们没有被元素节点分割，所有相邻的文本值将被浏览器解析成一个文本节点。但是，当我们主动创建多个文本节点并插入到 DOM 树中时，浏览器却不会合并这些相邻的文本节点。</p>
						<section>
							<h4>元素内所有文本值</h4>
							<p class="head-indent">当元素节点内的文本值被多个元素节点分割时，这些文本值会被解析成多个文本节点。元素节点的<code>innerHTML</code>属性获取的是该节点内的所有后代节点（包括文本节点与元素节点），而我们有时候却只想查看该节点的所有文本值（所有文本节点合并而成），下面就来看看如何查看。</p>
							<ul>
								<li>textContent</li>
							</ul>
							<pre class="language-markup"><code>&lt;body&gt;
  	&lt;h1&gt;Hello &lt;i&gt;World!&lt;/i&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;script&gt;
	var eleO = document.querySelector('h1');
	// 获取所有文本值
	console.log(eleO.textContent); // Hello World!
	// 设置所有文本值
	eleO.textContent = 'Hello World!';
	console.log(eleO.textContent); // Hello World!
&lt;/script&gt;</code></pre>
							<p class="head-indent"><b>我们会发现，<code>textContent</code>与<code>innerHTML</code>获取的值不同，但是它们在进行设置时行为却是一样的，也就是说会覆盖掉目标元素节点内的所有后代节点。</b></p>
						</section>
						<section>
							<h4>合并多个文本节点</h4>
							<p class="head-indent">当有多个相邻的文本节点存在时，我们可以让其合并成一个文本节点，只需要在它们的父元素节点上使用<code>normalize()</code>方法即可，这里不再做示例。</p>
							<ul>
								<li>normalize()</li>
							</ul>
						</section>
					</section>
				</section>
				<section>
					<h2>结语</h2>
					<p class="head-indent">文本节点的属性及方法大部分都可以用在注释节点（Comment）上。</p>
				</section>
				<section>
					<h2>参考</h2>
					<p>《DOM启蒙》，Cody Lindley，陈养剑 译</p>
				</section>
			</div>			
		</div>		
	</div>
	
	<script src="/source/js/prism.js"></script>
</body>
</html>