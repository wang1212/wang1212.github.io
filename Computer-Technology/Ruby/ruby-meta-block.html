<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Ruby-元编程之代码块 | 不如怀念</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://wang1212.github.io/Computer-Technology/Ruby/ruby-meta-block"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Ruby-元编程之代码块 | 不如怀念"><meta data-rh="true" name="description" content="这篇文章讲述关于 Ruby 中代码块相关的知识，这也是 Ruby 的特色。事实上，有很多编程语言都具备元编程的能力，而 Ruby 则是将元编程发挥到极致的语言。元编程这个概念是模糊的，很多人都说是用代码生成代码的方式，不过我们不用去纠结这个概念。元编程最具有魅力的地方就是，原来我们还可以在程序运行时去操控代码。"><meta data-rh="true" property="og:description" content="这篇文章讲述关于 Ruby 中代码块相关的知识，这也是 Ruby 的特色。事实上，有很多编程语言都具备元编程的能力，而 Ruby 则是将元编程发挥到极致的语言。元编程这个概念是模糊的，很多人都说是用代码生成代码的方式，不过我们不用去纠结这个概念。元编程最具有魅力的地方就是，原来我们还可以在程序运行时去操控代码。"><meta data-rh="true" name="keywords" content="计算机技术,Ruby,元编程,Block"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2016-12-05T15:33:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/wang1212"><meta data-rh="true" property="article:tag" content="计算机技术,Ruby,元编程,Block"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://wang1212.github.io/Computer-Technology/Ruby/ruby-meta-block"><link data-rh="true" rel="alternate" href="https://wang1212.github.io/Computer-Technology/Ruby/ruby-meta-block" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://wang1212.github.io/Computer-Technology/Ruby/ruby-meta-block" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="不如怀念 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="不如怀念 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.1eb3e63c.css">
<link rel="preload" href="/assets/js/runtime~main.d02f6e02.js" as="script">
<link rel="preload" href="/assets/js/main.3e56121a.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">不如怀念</b></a><a class="navbar__item navbar__link" href="/archive">归档</a><a class="navbar__item navbar__link" href="/record">记录</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/wang1212/wang1212.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Source<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">近期文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/3D/web-3d-practical-case-2">Web 3D 开发实践：计算物体在 2D 平面上的像素尺寸</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/Tools/tools-docusaurus">探索 Docusaurus 的路由实现</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/Web/web-tips-fonts">Web 字体加载对 DOM 位置的影响</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/3D/web-3d-practical-case-1">Web 3D 开发实践：3D 月球组件</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/TypeScript/tools-typescript-use-script-to-ts-types">利用脚本执行 `tsc` 忽略类型检查错误</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/Web/tools-web-fee-toolchain">前端工程化：对于构建工具链的简单思考</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/Program-Architecture-Design/bridge-mode-design-of-cross-platform-event-mechanism">桥接模式：跨平台的事件机制设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Tools/tools-animation-math">从贝塞尔曲线的计算感受数学建模的魅力</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Computer-Technology/Tools/tools-maintain-open-source-projects-with-tools">如何更好的维护开源项目</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/Life/2022-life-blog">细数博客的这几年</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Ruby-元编程之代码块</h1><div class="container_mt6G margin-vert--md"><time datetime="2016-12-05T15:33:00.000Z" itemprop="datePublished">2016年12月5日</time> · <!-- -->阅读需 14 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/wang1212" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="/img/authors/wang1212.png" alt="不如怀念"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/wang1212" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">不如怀念</span></a></div><small class="avatar__subtitle" itemprop="description">Web 前端工程师 (Web Front-end Engineer)</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><blockquote><p><em>最后更新于 2016-12-05 15:33:00 </em></p></blockquote><u>本文的代码均在 Ruby 2.3.0 环境下测试通过。</u><br><br><p>这篇文章讲述关于 Ruby 中代码块相关的知识，这也是 Ruby 的特色。事实上，有很多编程语言都具备元编程的能力，而 Ruby 则是将元编程发挥到极致的语言。元编程这个概念是模糊的，很多人都说是用代码生成代码的方式，不过我们不用去纠结这个概念。元编程最具有魅力的地方就是，原来我们还可以在程序运行时去操控代码。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="代码块">代码块<a class="hash-link" href="#代码块" title="标题的直接链接">​</a></h2><p>块（Block）在 Ruby 中是一大特色，在某些应用过程中能够实现闭包，而且其内部的迭代器（iterator）的实现大量使用了块，下面就来探究一下在 Ruby 中的代码块吧。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="定义块">定义块<a class="hash-link" href="#定义块" title="标题的直接链接">​</a></h3><p>块（Block）即代码段，相对于一个完整的方法来说，块强调的是一种过程。在 Ruby 中块的定义形式有两种，下面结合实例来说明：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[1, 2, 3].each { |item|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>块的第一种定义形式为：<code>block_name { |arguments| ... }</code>。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].each do |item|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; c</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>块的第二种定义形式为：<code>block_name do |arguments| ... end</code>。</p><p><strong>在 Ruby 中，块是依赖于方法存在的，没有方法就没有块，块必须在方法定义之后才能定义。而且 <code>{...}</code> 形式比 <code>do...end</code> 形式的优先级高。</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="调用块">调用块<a class="hash-link" href="#调用块" title="标题的直接链接">​</a></h3><p>定义的块是不能自己自动执行的，我们需要主动调用才可以，调用的方式也有两种。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="yield-关键字">yield 关键字<a class="hash-link" href="#yield-关键字" title="标题的直接链接">​</a></h4><p>在方法内部我们可以使用 <code>yield</code> 关键字捕获关联块，并允许传入参数回调执行块。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 定义方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def each(*a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for element in a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # 捕获块，回调执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        yield(element)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 定义块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">each(1,2,3) do |item|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts item * 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; 6</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="-尾部参数捕获">&amp; 尾部参数捕获<a class="hash-link" href="#-尾部参数捕获" title="标题的直接链接">​</a></h4><p>其实，每个方法都有一个默认的带 <code>&amp;</code> 操作符的尾部参数，该参数可以用来捕获方法关联块，从而使用 <code>call()</code> 方法调用块。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 定义方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def say(&amp;block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;Do you like dogs?&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 捕获块，回调执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block.call(&quot;yes&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block.call(&quot;no&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block.call()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 定义块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">say do |answer|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if answer == &quot;yes&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        puts &quot;I like dogs.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elsif answer == &quot;no&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        puts &quot;I like cats than dogs.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        puts &quot;I don&#x27;t know.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; Do you like dogs?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; I like dogs.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; I like cats than dogs.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; I don&#x27;t know.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>Ruby 中的块依赖于方法存在，块不是在定义的时候执行，而是被所关联方法用来回调执行，这也是比较重要的特性。</strong></p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="检测块">检测块<a class="hash-link" href="#检测块" title="标题的直接链接">​</a></h4><p>如果一个方法并没有定义关联块的话，在方法中去调用关联块则会发生运行时错误，此时我们可以使用 <code>block_given?()</code> 检测关联块是否已被定义。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">def test()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 检测块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return yield if block_given?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;no block&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test # ==&gt; no block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test { puts &quot;block is here&quot; } # ==&gt; block is here</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="作用域">作用域<a class="hash-link" href="#作用域" title="标题的直接链接">​</a></h2><p>说到代码块，我们不得不来谈谈作用域，Ruby 拥有严格的作用域机制，而块并没有形成严格意义上的独立作用域，这使得块可以实现闭包，而这一特性是非常有用的。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="作用域机制">作用域机制<a class="hash-link" href="#作用域机制" title="标题的直接链接">​</a></h3><p>通常作用域都是对于局部变量来说的，下面来演示一下 Ruby 中的独立作用域机制。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 进入顶级独立作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local_variable = &#x27;a&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module Outter  # 进入模块独立作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    local_variable = &#x27;b&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Inner  # 进入类独立作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        local_variable = &#x27;c&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        def func  # 进入方法独立作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            local_variable = &#x27;d&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该示例在四个作用域中定义了四个同名局部变量，但它们并不是相互覆盖的关系，而是各自独立的。</p><p><strong>在 Ruby 中，<code>module</code>、<code>class</code>、<code>def</code>（模块、类、方法）均会创建自己的独立作用域，所谓独立作用域即就是双向封闭的作用域，内外作用域不可相互直接访问。</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="块的作用域">块的作用域<a class="hash-link" href="#块的作用域" title="标题的直接链接">​</a></h3><p><strong>一个代码块并不会创建独立作用域，它可以穿透（访问）自身定义时所处上下文的作用域，但是自身对外部作用域却是单向封闭的。</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">def test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x = 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;method_local_x=#{x}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y = 1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield(y)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;method_local_x=#{x}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x =10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">puts &quot;main_local_x=#{x}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test do |y|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;block_x=#{x}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x += y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">puts &quot;main_local_x=#{x}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; main_local_x=10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; method_local_x=100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; block_x=10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; method_local_x=100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; main_local_x=1010</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该示例中，块中访问的 <code>x</code> 本地变量是其定义上下文中的本地变量，而并非是回调执行块时方法中的本地变量；同时，在调用块时将方法中的 <code>y</code> 本地变量传入块，从而了达到了存在于两个不同独立作用域中本地变量交互的目的。</p><p>事实上，我们已经感受到了块作用域的具有吸引力的特性。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="扁平化作用域">扁平化作用域<a class="hash-link" href="#扁平化作用域" title="标题的直接链接">​</a></h3><p>在讨论完 Ruby 严格的作用域机制与块作用域之后，我们似乎可以干点什么。没错，利用块作用域来打破这种严格的作用域机制。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">local_variable = &quot;a&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Outter = Module.new do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;module-&gt;main:&quot; + local_variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Inner = Class.new do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        puts &quot;class-&gt;main:&quot; + local_variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        define_method :func do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            puts &quot;method-&gt;main:&quot; + local_variable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; module-&gt;main:a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; class-&gt;main:a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Inner.new.func()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; method-&gt;main:a</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看见了吧，Ruby 严格的作用域机制被完全打破，整个作用域由里向外依次透明化，但块作用域是单向封闭的，所以由外向里又是封闭的。</p><p>也许你会觉得不可思议，这被称为扁平化作用域，官方名称则为<strong>嵌套文法作用域</strong>，我们可以利用该技术来共享作用域。</p><p>这里需要说明一下，方法也是一个 <code>Method</code> 对象，可以通过 <code>unbind()</code> 方法与所属对象解绑，再用 <code>bind()</code> 方法与其它所属同类的对象重新绑定。同时，方法可以调用 <code>to_proc()</code> 方法转化成一个 Proc 对象，也可以使用 <code>define_method()</code> 方法将块转化为一个方法，如示例中所示。<strong>方法绑定的作用域是所属对象的作用域，而块绑定的是定义块的作用域。</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="上下文探针">上下文探针<a class="hash-link" href="#上下文探针" title="标题的直接链接">​</a></h3><p>当一个对象的实例变量没有提供外部接口时，我们可以访问和改变吗？答案是可以的。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Person</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def initialize(name,age)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p = Person.new(&quot;MrWang&quot;,18);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p.instance_eval do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;#{@name} #{@age} 岁&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @age = 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;#{@name} #{@age} 岁&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; MrWang 18 岁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ==&gt; MrWang 20 岁</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>我们通过对象调用 <code>instance_eval()</code> 方法创建了一个块，该块内部作用域则是对象自身作用域，<code>self</code> 指向对象自身。</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">p.instance_exec(20) do |age|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;#{@name} #{@age} 岁&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @age = age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    puts &quot;#{@name} #{@age} 岁&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>instance_eval()</code> 方法是不允许传递块参数的，而 <code>instance_exec()</code> 会将方法的参数传递给块参数。</p><p>这么做看起来像是破坏了对象的封装性，不过这些方法我认为是为程序员服务的，而不是用户。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="proc-对象">Proc 对象<a class="hash-link" href="#proc-对象" title="标题的直接链接">​</a></h2><p>我们一直说块是依赖于方法的，其实我们可以创建独立于方法的 <code>Proc</code> 可调用对象。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="procnew">Proc.new<a class="hash-link" href="#procnew" title="标题的直接链接">​</a></h3><p>我们可以创建不依赖于特定方法的块，并存储下来供合适的时候多次重复利用，而 <code>Proc</code> 对象就是一种可调用对象，事实上我们已经见过它了。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">inc = Proc.new { |x| puts x + 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add = proc { |a,b| puts a + b }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inc.call(2);  # ==&gt; 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inc.call(5);  # ==&gt; 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add.call(2,3)  # ==&gt; 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add.call(4,3)  # ==&gt; 7</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用 <code>Proc.new()</code> 与 <code>proc()</code> 方法是等价的，Proc 对象使用 <code>call()</code> 方法调用传参。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">def test(&amp;block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p = test { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">puts p.class  # ==&gt; Proc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其实与方法关联的块在使用尾部参数捕获后，去掉 <code>&amp;</code> 操作符就是一个 <code>Proc</code> 对象，加上 <code>&amp;</code> 又是一个块（可以传递给其他方法），这样可以相互转换。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="lambda-表达式匿名方法">lambda 表达式（匿名方法）<a class="hash-link" href="#lambda-表达式匿名方法" title="标题的直接链接">​</a></h3><p>还有一种方式可以创建 <code>Proc</code> 对象，也就是 <code>lambda()</code> 方法或者 <code>-&gt;()</code>（箭头方法）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">inc = lambda { |x| x + 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add = -&gt;(a,b) { puts a+b }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inc.call(2);  # ==&gt; 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add.call(2,3);  # ==&gt; 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">puts inc.class  # ==&gt; Proc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="区别">区别<a class="hash-link" href="#区别" title="标题的直接链接">​</a></h3><p>虽然说，前后创建的都是 <code>Proc</code> 对象，但它们还是有一些细微区别的。</p><ul><li><p>return</p><p>前者创建的 Proc 对象中如果使用 <code>return</code>，则意味着程序中断（结束）；而使用 <code>lambda()</code> 创建的 Proc 对象中使用 <code>return</code> 就像调用方法返回值一样，仅仅是调用的块执行结束。</p></li><li><p>参数检查</p><p>前者创建的 Proc 对象调用时参数可多可少，多的忽略，少的赋为 <code>nil</code>；而使用 <code>lambda()</code> 创建的 Proc 对象调用时会进行参数个数检查，必须对应，传入的参数不能多也不能少。</p></li></ul><p>看起来，<code>lambda()</code> 创建的 Proc 对象更像方法，我们称之为<strong>匿名方法</strong>。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="闭包">闭包<a class="hash-link" href="#闭包" title="标题的直接链接">​</a></h2><p>当一个方法执行完毕后，该方法的独立作用域会销毁，方法里面的局部变量自然也会随之销毁；但是基于块作用域的特性，我们可以实现闭包。</p><p><strong>若方法中存在一个独立于方法的块（非关联块），该独立块具备块作用域特性，可访问定义时上下文（单次方法调用）的外部作用域，该块被外部引用后，即便是所在方法执行完毕后，因为块的存在绑定了方法中的局部变量，因而不会随方法销毁，这就是闭包。</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">def closure(n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x = n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -&gt; {x *= 10; puts &quot;block_local_x=#{x}&quot;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 获取方法内块的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_1 = closure(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_2 = closure(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_1.call  # ==&gt; block_local_x=10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_2.call  # ==&gt; block_local_x=20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_1.call  # ==&gt; block_local_x=100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_2.call  # ==&gt; block_local_x=200</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_1.call  # ==&gt; block_local_x=1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">closure_2.call  # ==&gt; block_local_x=2000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述示例表明，当外部获取方法内的块引用之后，方法内的局部变量便被块绑定，之后依然可以访问；同时，不同的外部引用的块绑定的是不同的局部变量，这是因为两个块定义上下文（作用域）不同。</p><p>从块作用域的特性来仔细分析，它不仅有吸引力让我们可以实现闭包，同时也存在内存泄露的风险。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="结语">结语<a class="hash-link" href="#结语" title="标题的直接链接">​</a></h2><p>可以说块在 Ruby 中无处不在，合理的利用块可以省去不少代码，更能实现更强大的功能。块中需要注意的是，块不是定义时执行的，而是回调执行的；块作用域两大特点也非常重要。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="参考">参考<a class="hash-link" href="#参考" title="标题的直接链接">​</a></h2><ul><li>《Ruby 元编程》，<!-- -->[意]<!-- --> Paolo Perrotta，廖志刚 译</li><li>《Ruby 基础教程》，<!-- -->[日]<!-- --> 高桥征义 后藤裕藏，何文斯 译</li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/计算机技术">计算机技术</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/ruby">Ruby</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/元编程">元编程</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/block">Block</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/wang1212/wang1212.github.io/tree/master/blog/Computer-Technology/Ruby/ruby-meta-block.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/Computer-Technology/Ruby/ruby-meta-class"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">Ruby-元编程之类</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Computer-Technology/Linux/linux-cmd-vim"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">Linux-Vim 编辑器</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#代码块" class="table-of-contents__link toc-highlight">代码块</a><ul><li><a href="#定义块" class="table-of-contents__link toc-highlight">定义块</a></li><li><a href="#调用块" class="table-of-contents__link toc-highlight">调用块</a></li></ul></li><li><a href="#作用域" class="table-of-contents__link toc-highlight">作用域</a><ul><li><a href="#作用域机制" class="table-of-contents__link toc-highlight">作用域机制</a></li><li><a href="#块的作用域" class="table-of-contents__link toc-highlight">块的作用域</a></li><li><a href="#扁平化作用域" class="table-of-contents__link toc-highlight">扁平化作用域</a></li><li><a href="#上下文探针" class="table-of-contents__link toc-highlight">上下文探针</a></li></ul></li><li><a href="#proc-对象" class="table-of-contents__link toc-highlight">Proc 对象</a><ul><li><a href="#procnew" class="table-of-contents__link toc-highlight">Proc.new</a></li><li><a href="#lambda-表达式匿名方法" class="table-of-contents__link toc-highlight">lambda 表达式（匿名方法）</a></li><li><a href="#区别" class="table-of-contents__link toc-highlight">区别</a></li></ul></li><li><a href="#闭包" class="table-of-contents__link toc-highlight">闭包</a></li><li><a href="#结语" class="table-of-contents__link toc-highlight">结语</a></li><li><a href="#参考" class="table-of-contents__link toc-highlight">参考</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><a href="https://github.com/wang1212/awesome-favorites-list" target="_blank" rel="noopener noreferrer" class="footer__link-item">收藏列表<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="https://wang1212.github.io/the-book-of-ruby/" target="_blank" rel="noopener noreferrer" class="footer__link-item">The Book Of Ruby(zh)<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="mailto:mrwang1212@126.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">Email<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="https://github.com/wang1212" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><span class="footer__link-separator">·</span><a href="https://gitee.com/i_wang1212" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Blog. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d02f6e02.js"></script>
<script src="/assets/js/main.3e56121a.js"></script>
</body>
</html>