<!DOCTYPE html>
<html lang="en">
<body>
	<header class="hidden-sm-down text-xs-left">
		<p class="h1 text-xs-center">Chapter Two</p><hr />
		<p class="h2 text-xs-center">Class Hierarchies, Attributes and Class Variables</p>
		<ul>
			<li class="h3">Superclasses and Subclasses</li>
			<li class="h3">Passing Arguments To The Superclass</li>
			<li class="h3">Accessor Methods</li>
			<li class="h3">'Set' Accessors</li>
			<li class="h3">Attribute Readers and Writers</li>
			<li class="h3">Calling Methods of a Superclass</li>
			<li class="h3">Class Variables</li>
		</ul>
		<p class="h2 text-xs-center">Digging Deeper</p>
		<ul>
			<li class="h3">Superclasses</li>
			<li class="h3">Constants Inside Classes</li>
			<li class="h3">Partial Classes</li>
		</ul>
	</header>
	<h1>第二章</h1><hr />
	<section>
		<h2 id="page-title">类的层次结构、属性与变量</h2>
		<p class="head-indent">
			在上一节结束时我们创建两个类：Thing 和 Treasure，尽管事实上这两个类共享了一些功能（特别是两者都包含 'name'），但它们是没有联系的。
		</p>
		<p class="head-indent">
			现在，这两个类的重复看起来是不值一提的。但是，当你开始写一些复杂的程序时，你的类将会包含大量的变量和方法；你真的想将同样的事情一遍又一遍的重复吗。
		</p>
		<p class="head-indent">
			对于其中一个类是其它（祖先）类的特殊类型结构来说创建一个类层次是更有意义的，这种情况下它会自动继承（inherit）祖先类的特征。例如，在我们简单的冒险游戏中，Treasure 是 Thing 的一个特殊的类型，因此 Treasure 就会继承 Thing 类的特征。
		</p>
		<div class="note head-indent">
			<strong>类层次——祖先（Ancestors）和后代（Descendants）：</strong>在这本书中，我会经常提及“后代”类继承（inherit）自它们祖先类，这些术语意味着“相关”类之间的一种类似于家庭的关系。Ruby 中每一个类只有一个父亲，然而，它可能在一个很长很大的家庭树中，有许多代的父母、祖父母等等...
		</div>
		<p class="head-indent">
			Thing 类的特征通常被定义在它内部，Treasure 类则会自动地“继承” Thing 类所有的的特性。所以，我们不需要再次对这些特征进行编码，而是额外添加一些 Treasures 类特有的特性。
		</p>
		<p class="head-indent">
			通常地规则是，在创建类层次结构时，具有更多通用特征的类要比具有更多特殊特征的类层次更高一些。所以，只有一个 <i>name</i> 和 <i>description</i> 的 Thing 类是具有 <i>name</i>、<i>description</i> 以及 <i>value</i> 的 Treasure 类的祖先；Thing 类也可能是一些其它的特殊类的祖先，例如具有 <i>name</i>、<i>description</i> 以及 <i>exits</i> 的 Room 类。
		</p>
		<div class="note">
			<dl>
				<dt><strong>一个父亲，有多个孩子...</strong></dt>
				<dd class="head-indent">
					Thing 类具有 <i>name</i> 和 <i>description</i> （在 Ruby 程序中，它们可能是内部变量<code>@name</code>和<code>@description</code>）。Treasure 和 Room 类都派生自 Thing 类，所以它们自动地继承了 <i>name</i> 和 <i>description</i> 。Treasure 类添加了一个 <i>value</i>，所以它就具有 <i>name</i>、<i>description</i> 和 <i>value</i> ；Room 类添加了一个 <i>exits</i>，所以它就具有 <i>name</i>、<i>description</i> 和 <i>exits</i> 。
				</dd>
			</dl>
		</div>
		<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;1adventure.rb</div>
		<p class="head-indent">
			来让我们看看如何在 Ruby 中创建一个后代类。加载 <strong>1adventure.rb</strong> 程序，这只需要定义一个具有两个实例变量（instance variables）<code>@name</code>和<code>@description</code>的 Thing 类，它们的值可以在创建新的 Thing 对象时在<code>initialize</code>方法中赋值。
		</p>
		<p class="head-indent">
			实例变量通常不能（也不应该）被外部直接访问，这是为了遵循上一章讲到的封装（ encapsulation）原则。为了获得我们所需要的每个变量的值，我们需要一个 get 访问器方法，例如<code>get_name</code>；为了给某个变量赋一个新值，我们也需要一个 set 访问器方法，例如<code>set_name</code>。
		</p>
		<section>
			<h3>超类与子类</h3>
			<p class="head-indent">现在来看看 Treasure 类，注意声明方式：</p>
			<pre class="language-ruby line-numbers"><code>class Treasure < Thing</code></pre>
			<p class="head-indent">
				尖括号<code>&lt;</code>表示 Treasure 是 Thing 的一个子类（后代类），因此它从 Thing 类继承数据（变量）和行为（方法）。因为<code>get_name</code>、<code>set_name</code>、<code>get_description</code>以及<code>set_description</code>方法已经存在于 Thing 类中，所以不需要在后代类（Treasure）中再编写了。
			</p>
			<p class="head-indent">
				Treasure 类还有额外的数据，也就是它的 value（<code>@value</code>），我已经为它编写了 <em>get</em> 和 <em>set</em> 访问器了。当创建一个新的 Treasure 对象时，它的<code>initialize</code>方法会被自动调用。一个 Treasure 对象有三个变量（<code>@name</code>、<code>@description</code>和<code>@value</code>）需要初始化，所以它的<code>initialize</code>方法有三个参数。前两个参数使用<code>super</code>关键字传递给超类（Thing）的<code>initialize</code>方法，以便 Thing 类的<code>initialize</code>方法可以处理它们：
			</p>
			<pre class="language-ruby line-numbers"><code>super(aName, aDescription)</code></pre>
			<p class="head-indent">
				当在方法中使用时，<code>super</code>关键字调用在祖先类或超类中的与当前所在方法的同名方法。如果<code>super</code>关键字没有指定任何参数，当前方法的所有参数将会传递给祖先类的方法。但是，像本例中一样，提供了一个特定的参数列表时（这里是<code>aName</code>和<code>aDescription</code>），那么只有这些参数会被传递给祖先类的方法。
			</p>
		</section>
		<section>
			<h3>向超类传递参数</h3>
			<p class="head-indent">
				当调用超类的方法时，括号是很重要的！如果参数列表为空，并且没有使用括号，那么所有的参数都将传递给超类。但是，参数列表为空，并且使用了括号时，将不会给超类传递任何参数。
			</p>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;super_args.rb</div>
			<pre class="language-ruby line-numbers"><code># This passes a, b, c to the superclass
def initialize(a, b, c, d, e, f)
  super(a, b, c)
end
# This passes a, b, c to the superclass
def initialize(a, b, c)
  super 
end
# This passes no arguments to the superclass
def initialize(a, b, c)
  super()
end</code></pre>
			<div class="note">
				要更好的了解<code>super</code>关键字的使用，请参阅本章末尾的<strong>深入探索</strong>部分。
			</div>
		</section>
		<section>
			<h3>访问器方法</h3>
			<p class="head-indent">
				虽然这些类在冒险游戏中运行的足够好，但它们仍然是累赘的，因为设置了大量的 <em>get</em> 和 <em>set</em> 访问器方法。让我们看看有什么补救措施。
			</p>
			<p class="head-indent">
				替换掉<code>@description</code>实例变量的两个不同的方法，<code>get_description</code>和<code>set_description</code>。
			</p>
			<pre class="language-ruby line-numbers"><code>puts(t1.get_description)
t1.set_description(“Some description”)</code></pre>
			<p class="head-indent">取值和赋值也许更好一些，对于一个简单的变量使用下面的方式进行取值和赋值：</p>
			<pre class="language-ruby line-numbers"><code>puts(t1.description)
t1.description = “Some description”</code></pre>
			<p class="head-indent">
				为了能够做到这一点，我们需要修改 Treasure 类的定义。实现这一点的方法是重写<code>@description</code>的访问器方法：
			</p>
			<pre class="language-ruby line-numbers"><code>def description
  return @description
end

def description=(aDescription)
  @description = aDescription
end</code></pre>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;accessors1.rb</div>
			<p class="head-indent">
				我已经在 <strong>accessors1.rb</strong> 中添加了类似于上面的访问器。<em>get</em> 访问器被称为<code>description</code>，<em>set</em> 访问器被称为<code>description=</code>（即就是，将等号（=）附加到 <em>get</em> 访问器方法名后面）。现在，就可以将一个新的字符串进行赋值了：
			</p>
			<pre class="language-ruby line-numbers"><code>t.description = "a bit faded and worn around the edges"</code></pre>
			<p class="head-indent">你可以像这样取值：</p>
			<pre class="language-ruby line-numbers"><code>puts(t.description)</code></pre>
		</section>
		<section>
			<h3>'Set' 访问器</h3>
			<p class="head-indent">
				当你想要以这种方式编写 set 访问器时，必须将<code>=</code>字符附加到方法名后面，而不仅仅是将其放置于方法名和参数之间。
			</p>
			<p class="head-indent">所以，这样是正确的：</p>
			<pre class="language-ruby"><code>def name=(aName)</code></pre>
			<p class="head-indent">这样是错误的：</p>
			<pre class="language-ruby"><code>def name = (aName)</code></pre>
		</section>
		<section>
			<h3>属性的读与写</h3>
			<p class="head-indent">
				事实上，有一个更简单的方式实现相同的功能。所有你要做的就是使用两个特殊的方法，<code>attr_reader</code>和<code>attr_writer</code>，后跟一个符号（symbol）：
			</p>
			<pre class="language-ruby line-numbers"><code>attr_reader :description
attr_writer :description</code></pre>
			<p class="head-indent">你可以添加这些代码到你的类定义中：</p>
			<pre class="language-ruby line-numbers"><code>class Thing
  attr_reader :description
  attr_writer :description
    # maybe some more methods here…
end</code></pre>
			<p class="head-indent">
				使用一个符号并调用<code>attr_reader</code>方法将会为命名与该符号（<code>:description</code>）相匹配的实例变量（<code>@description</code>）创建一个 <em>get</em> 访问器。
			</p>
			<p class="head-indent">
				调用<code>attr_writer</code>方法类似的将会为实例变量创建一个 <em>set</em> 访问器。实例变量被认为是一个对象的“属性”（attributes），这就是为什么<code>attr_reader</code>和<code>attr_writer</code>方法是这样命名的。
			</p>
			<div class="note">
				<dl>
					<dt>符号（Symbols）</dt>
					<dd class="head-indent">
						在 Ruby 中，一个符号是以冒号开头的（例如，<code>:description</code>）。<strong>Symbol</strong> 类在 Ruby 类库中定义，用来表示解释器中的命名。当你将一个或多个符号作为参数传递给<code>attr_reader</code>（这是一个 <strong>Module</strong> 类的方法）时，Ruby 会创建一个实例变量和一个 <em>get</em> 访问器方法。此访问器方法返回相应变量的值；实例变量和访问器方法都会使用该符号命名。所以，<code>attr_reader(:description)</code>会创建一个名为<code>@description</code>的实例变量，以及一个名为<code>description()</code>的访问器方法。
					</dd>
				</dl>
			</div>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;accessors2.rb</div>
			<p class="head-indent">
				<strong>accessors2.rb</strong> 程序包含一些属性读取器的示例。Thing 类为<code>@name</code>属性明确定义了 <em>get</em> 访问器方法，编写这样一个完整的方法的好处是，可以让你进行额外的处理，而不是简单的对属性的值进行读写。这里的 <em>get</em> 访问器使用<code>String.capitalize</code>方法返回<code>@name</code>的字符串值及其初始值的大写形式。
			</p>
			<pre class="language-ruby line-numbers"><code>def name
  return @name.capitalize
end</code></pre>
			<p class="head-indent">当为<code>@name</code>属性进行赋值时，我不需要进行特殊的处理，所以我可以这么写：</p>
			<pre class="language-ruby line-numbers"><code>attr_writer :name</code></pre>
			<p class="head-indent">
				<code>@description</code>属性不需要特殊处理，所以我使用<code>attr_reader</code>和<code>attr_writer</code>去获取和设置<code>@description</code>变量的值：
			</p>
			<pre class="language-ruby line-numbers"><code>attr_reader :description
attr_writer :description</code></pre>
			<div class="note">
				<dl>
					<dt>Attributes or Properties?</dt>
					<dd class="head-indent">
						不要对术语感到困惑，在 Ruby 中，"Attribute" 相当于许多编程语言中的 "Propertie"。
					</dd>
				</dl>
			</div>
			<p class="head-indent">
				当你想允许对一个变量同时可以进行读和写操作时，<code>attr_accessor</code>方法提供了替代<code>attr_reader</code>和<code>attr_writer</code>方法的简洁语法。我已经使用它来访问 Treasure 类中的 value 属性：
			</p>
			<pre class="language-ruby line-numbers"><code>attr_accessor :value</code></pre>
			<p class="head-indent">这等同于：</p>
			<pre class="language-ruby line-numbers"><code>attr_reader :value
attr_writer :value</code></pre>
			<p class="head-indent">
				前面我说过，使用一个符号并调用<code>attr_reader</code>实际上会创建一个名字与符号相同的变量。<code> attr_accessor</code>方法也是一样的。
			</p>
			<p class="head-indent">
				在 Thing 类的代码中，因为<code>initialize</code>方法显式创建了变量，所以这并不明显。然而，Treasure 类没有在它的<code>initialize</code>方法中引用<code>@value</code>变量。只存在<code>@value</code>访问器的定义：
			</p>
			<pre class="language-ruby line-numbers"><code>attr_accessor :value</code></pre>
			<p class="head-indent">在我的源文件代码的底部，每个 Treasure 对象创建后都单独设置了 value 的值。</p>
			<pre class="language-ruby line-numbers"><code>t1.value = 800</code></pre>
			<p class="head-indent">
				即使从没有正式的声明，<code>@value</code>变量却是真实存在的，我们能够使用 <em>get</em> 访问器获取其数值。
			</p>
			<pre class="language-ruby line-numbers"><code>t1.value</code></pre>
			<p class="head-indent">
				要绝对地确定属性访问器真的已经创建了<code>@value</code>，你可以使用<code>inspect</code>方法查看对象的内部。我在这个程序的最后两行代码就是这么做的：
			</p>
			<pre class="language-ruby line-numbers"><code>puts "This is treasure1: #{t1.inspect}"
puts "This is treasure2: #{t2.inspect}"</code></pre>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;accessors3.rb</div>
			<p class="head-indent">属性访问器可以同时初始化超过一个属性，你可以传递一个用逗号分隔的符号列表：</p>
			<pre class="language-ruby line-numbers"><code>attr_reader :name, :description
attr_writer(:name, :description)
attr_accessor(:value, :id, :owner)</code></pre>
			<p class="head-indent">和往常一样，在 Ruby 中参数列表的括号是可选的，但在我看来（为了清楚起见）括号是必选的。</p>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;2adventure.rb</div>
			<p class="head-indent">
				现在让我们看看如何将属性读写用在我们的冒险游戏中。加载 <strong>2adventure.rb</strong> 程序。你会看到我在 Thing 类中创建了两个可读的属性：<code>name</code>和<code>description</code>。我同时也让<code>description</code>是可写的。然而，我不打算改变任何一个 Thing 对象的 name，所以<code>name</code>是不可写的：
			</p>
			<pre class="language-ruby line-numbers"><code>attr_reader(:name, :description)
attr_writer(:description)</code></pre>
			<p class="head-indent">
				我创建了一个用来返回描述 Treasure 对象的字符串的<code>to_s</code>方法。回想一下，所有的 Ruby 类都有一个标准的<code>to_s</code>方法，<code>Thing.to_s</code>方法覆盖（替换）了默认的方法。当您希望实现适合特定类类型的新行为时，你可以覆盖现有的方法。
			</p>
		</section>
		<section>
			<h3>调用超类方法</h3>
			<p class="head-indent">
				我已经决定我的游戏会有两个派生自 Thing 的后代类。Treasure 类添加了一个可读写的<code>value</code>属性；注意它的<code>initialize</code>方法中调用了超类方法，是为了在初始化新变量<code>@value</code>之前</code>初始化<code>name</code>和<code>description</code>属性：
			</p>
			<pre class="language-ruby line-numbers"><code>super(aName, aDescription)
@value = aValue</code></pre>
			<p class="head-indent">
				在这里如果我省略了对超类方法的调用，那么<code>name</code>和<code>description</code>属性将永远不会被初始化。这是因为<code>Treasure.initialize</code>覆盖了<code>Thing.initialize</code>，所以当一个 Treasure 对象被创建时，<code>Thing.initialize</code>代码不会自动被执行。
			</p>
			<p class="head-indent">
				另一方面，<code>Room</code>类也派生自 Thing，目前没有<code>initialize</code>方法；所以当一个新的 Room 对象被创建时，Ruby 会从类层次中逐层向上寻找该方法。第一个<code>initialize</code>方法在 Thing 中被发现；所以一个 Room 对象的<code>name</code>和<code>description</code>属性在这里被初始化。
			</p>
		</section>
		<section>
			<h3>类变量</h3>
			<p class="head-indent">在这个程序中还有一些其他的有趣的东西。在顶级类 Thing 中你会看到：</p>
			<pre class="language-ruby line-numbers"><code>@@num_things = 0</code></pre>
			<p class="head-indent">
				此变量的名字是以两个 <strong>@</strong> 字符开头的，<code>@@num_things</code>定义这是一个“类变量”（class variable）。到目前为止，我们在类中使用的变量都是实例变量，以单个 <strong>@</strong> 开头，例如<code>@name</code>。而每个类的新对象（实例）会将自己的值分配给自己的实例变量，然而所有派生自特定类的对象共享相同的类变量。我已经给<code>@@num_things</code>赋值为 0 以确保其是有意义的。
			</p>
			<p class="head-indent">
				在这里，<code>@@num_things</code>类变量用来记录在游戏运行的 Thing 对象的数量。它只是在每个新对象被创建时在它的初始化方法中简单的递增类变量（通过<code>+=1</code>）：
			</p>
			<pre class="language-ruby line-numbers"><code>@@num_things +=1</code></pre>
			<p class="head-indent">
				如果你接着看我的代码，你会看到我创建一了包含 rooms 的数组（array）的 Map 类。这也包括一个标准的<code>to_s</code>方法，可以打印出数组中每个 room 的信息。不要担心 Map 类的实现，我们将在后面章节讨论数组及其方法。
			</p>
			<p class="head-indent">
				滚动到代码文件的底部，然后运行程序看看我是如何创建和初始化所有的对象以及使用类变量，<code>@@num_things</code>，来记录已创建的 Thing 对象的数量。
			</p>
			<div class="note">
				<dl>
					<dt class="text-xs-center"><strong>类变量与实例变量</strong></dt>
					<dd class="head-indent">
						对于 Thing 类，如有三个不同的 Thing 对象（实例），<code>@name</code>作为实例变量，因各个对象（实例）的不同而取值不同；并且各个对象之间修改<code>@name</code>的值并不会相互影响，是独立的。Thing 类中有一个<code>@@num_things</code>类变量，它被三个对象共享，其中一个修改<code>@@num_things</code>的值时，其它对象访问到<code>@@num_things</code>的值也会发生改变。所以说，实例变量<code>@name</code>是对象独有的，而类变量<code>@@num_things</code>是被所有对象共享的。
					</dd>
				</dl>
			</div>
		</section>
	</section>
	<section>
		<h2>深入探索</h2>
		<section>
			<h3>超类</h3>
			<div style="font-weight: 600"><span class="fa fa-file-code-o"></span>&nbsp;super.rb</div>
			<p class="head-indent">
				要理解 super 关键字的工作原理，请看我们的示例程序，<strong> super.rb </strong>。它包含五个相关类：Thing 类其他所有类的祖先；从 Thing 类衍生到 Thing2 类，再从 Thing2 类衍生到 Thing3 类，然后依次是 Thing4 和 Thing5 类。
			</p>
			<p class="head-indent">
				让我们仔细看看这个层次中的前三个类：Thing 类有两个实例变量，<code>@name</code>和<code>@description</code>；Thing2 类也定义了<code>@fulldescription</code>（一个包含<code>@name</code>与<code>@description</code>的字符串）；Thing3 类则添加了另一个变量<code>@value</code>。
			</p>
			<p class="head-indent">
				这三个类各自包含一个<code>initialize</code>方法，用来在创建新对象时设置变量的值；它们各自也有一个名为<code>aMethod</code>的方法，用来改变一个或多个变量的值。后代类 Thing2 和 Thing3 在它们的方法中都使用了<code>super</code>关键字。
			</p>
			<div class="note head-indent">
				在命令窗口运行 <strong>super.rb</strong> 。去按位测试代码，键入 1 到 5的一个数字，当有提示时或者键入 'q' 退出。
			</div>
		</section>
		<section>
			<h3>类中的常量</h3>
		</section>
		<section>
			<h3>局部类</h3>
		</section>
	</section>
</body>
</html>